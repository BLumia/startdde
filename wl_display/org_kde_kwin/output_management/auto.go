// package output_management acts as a client for the outputmanagement wayland protocol.

// generated by wl-scanner
// https://github.com/dkolbly/wl-scanner
// from: output-management.xml
// on 2020-01-20 20:33:44 +0800
package output_management

import (
	"sync"

	"github.com/dkolbly/wl"
	"golang.org/x/net/context"
	"pkg.deepin.io/dde/startdde/wl_display/org_kde_kwin/outputdevice"
)

type Outputmanagement struct {
	wl.BaseProxy
}

func NewOutputmanagement(ctx *wl.Context) *Outputmanagement {
	ret := new(Outputmanagement)
	ctx.Register(ret)
	return ret
}

// CreateConfiguration will provide outputconfiguration object for configuring outputs.
//
//
// Request an outputconfiguration object through which the client can configure
// output devices.
//
func (p *Outputmanagement) CreateConfiguration() (*Outputconfiguration, error) {
	ret := NewOutputconfiguration(p.Context())
	return ret, p.Context().SendRequest(p, 0, wl.Proxy(ret))
}

type OutputconfigurationAppliedEvent struct {
	EventContext context.Context
}

type OutputconfigurationAppliedHandler interface {
	HandleOutputconfigurationApplied(OutputconfigurationAppliedEvent)
}

func (p *Outputconfiguration) AddAppliedHandler(h OutputconfigurationAppliedHandler) {
	if h != nil {
		p.mu.Lock()
		p.appliedHandlers = append(p.appliedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Outputconfiguration) RemoveAppliedHandler(h OutputconfigurationAppliedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.appliedHandlers {
		if e == h {
			p.appliedHandlers = append(p.appliedHandlers[:i], p.appliedHandlers[i+1:]...)
			break
		}
	}
}

type OutputconfigurationFailedEvent struct {
	EventContext context.Context
}

type OutputconfigurationFailedHandler interface {
	HandleOutputconfigurationFailed(OutputconfigurationFailedEvent)
}

func (p *Outputconfiguration) AddFailedHandler(h OutputconfigurationFailedHandler) {
	if h != nil {
		p.mu.Lock()
		p.failedHandlers = append(p.failedHandlers, h)
		p.mu.Unlock()
	}
}

func (p *Outputconfiguration) RemoveFailedHandler(h OutputconfigurationFailedHandler) {
	p.mu.Lock()
	defer p.mu.Unlock()

	for i, e := range p.failedHandlers {
		if e == h {
			p.failedHandlers = append(p.failedHandlers[:i], p.failedHandlers[i+1:]...)
			break
		}
	}
}

func (p *Outputconfiguration) Dispatch(ctx context.Context, event *wl.Event) {
	switch event.Opcode {
	case 0:
		if len(p.appliedHandlers) > 0 {
			ev := OutputconfigurationAppliedEvent{}
			ev.EventContext = ctx
			p.mu.RLock()
			for _, h := range p.appliedHandlers {
				h.HandleOutputconfigurationApplied(ev)
			}
			p.mu.RUnlock()
		}
	case 1:
		if len(p.failedHandlers) > 0 {
			ev := OutputconfigurationFailedEvent{}
			ev.EventContext = ctx
			p.mu.RLock()
			for _, h := range p.failedHandlers {
				h.HandleOutputconfigurationFailed(ev)
			}
			p.mu.RUnlock()
		}
	}
}

type Outputconfiguration struct {
	wl.BaseProxy
	mu              sync.RWMutex
	appliedHandlers []OutputconfigurationAppliedHandler
	failedHandlers  []OutputconfigurationFailedHandler
}

func NewOutputconfiguration(ctx *wl.Context) *Outputconfiguration {
	ret := new(Outputconfiguration)
	ctx.Register(ret)
	return ret
}

// Enable will enable or disable an output.
//
//
// Mark the output as enabled or disabled.
//
func (p *Outputconfiguration) Enable(outputdevice *outputdevice.Outputdevice, enable int32) error {
	return p.Context().SendRequest(p, 0, outputdevice, enable)
}

// Mode will switch outputdevice to mode.
//
//
// Sets the mode for a given output by its mode size (width and height) and refresh rate.
//
func (p *Outputconfiguration) Mode(outputdevice *outputdevice.Outputdevice, mode_id int32) error {
	return p.Context().SendRequest(p, 1, outputdevice, mode_id)
}

// Transform will transform outputdevice.
//
//
// Sets the transformation for a given output.
//
func (p *Outputconfiguration) Transform(outputdevice *outputdevice.Outputdevice, transform int32) error {
	return p.Context().SendRequest(p, 2, outputdevice, transform)
}

// Position will position output in global space.
//
//
// Sets the position for this output device. (x,y) describe the top-left corner
// of the output in global space, whereby the origin (0,0) of the global space
// has to be aligned with the top-left corner of the most left and in case this
// does not define a single one the top output.
//
// There may be no gaps or overlaps between outputs, i.e. the outputs are
// stacked horizontally, vertically, or both on each other.
//
func (p *Outputconfiguration) Position(outputdevice *outputdevice.Outputdevice, x int32, y int32) error {
	return p.Context().SendRequest(p, 3, outputdevice, x, y)
}

// Scale will set scaling factor of this output.
//
//
// Sets the scaling factor for this output device.
//
func (p *Outputconfiguration) Scale(outputdevice *outputdevice.Outputdevice, scale int32) error {
	return p.Context().SendRequest(p, 4, outputdevice, scale)
}

// Apply will apply configuration changes to all output devices.
//
//
// Asks the server to apply property changes requested through this outputconfiguration
// object to all outputs on the server side.
//
func (p *Outputconfiguration) Apply() error {
	return p.Context().SendRequest(p, 5)
}

// Scalef will set scaling factor of this output.
//
//
// Sets the scaling factor for this output device.
// Sending both scale and scalef is undefined.
//
func (p *Outputconfiguration) Scalef(outputdevice *outputdevice.Outputdevice, scale float32) error {
	return p.Context().SendRequest(p, 6, outputdevice, scale)
}

// Colorcurves will set output color curves.
//
//
// Set color curves of output devices through RGB color ramps. Allows color
// correction of output device from user space.
//
// These are the raw values. A compositor might opt to adjust these values
// internally, for example to shift color temperature at night.
//
func (p *Outputconfiguration) Colorcurves(outputdevice *outputdevice.Outputdevice, red []int32, green []int32, blue []int32) error {
	return p.Context().SendRequest(p, 7, outputdevice, red, green, blue)
}

// Destroy will release the outputconfiguration object.
//
//
func (p *Outputconfiguration) Destroy() error {
	return p.Context().SendRequest(p, 8)
}
